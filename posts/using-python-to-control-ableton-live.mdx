---
title: "Using Python to Control Ableton Live"
date: "2023-03-10"
keywords: ["audio", "performance", "ableton", "python", "midi"]
summary: "While designing a new liveset with my band, I wrote some code to help me better and more efficiently navigate Ableton Live's session view using very few midi controls. Here is how I did it."
---

<MyImage
  src="/img/abletonmidi-overview1.gif"
  alt="overview of my setup to navigate Ableton Live using python"
/>

Designing live performances for <MyLink url="https://theholymountain.net">The Holy Mountain</MyLink> (my band) has always been challenging. During our live sets, we have to manage looping, sample triggering, complex tempo changes, and fast navigation between synthesizer presets.

For our upcoming liveset, I have been trying to figure out how to play drums and synthesizers simultaneously, playing synth with my right hand and drumming with my remaining limbs. This problem inspired me to develop a clever way to navigate <MyLink href="https://ableton.com/">Ableton Live</MyLink> using very few midi controls

In this post, I present my solution and demonstrate how you can use some Python code (essentially Generator objects and rtmidi) to achieve awesome midi mapping capabilities between your midi controller and DAW.

# Contents

<ol>
  <li>
    <MyLink href="#system-overview">System overview</MyLink>
  </li>
  <li>
    <MyLink href="#python-setup">Python Setup</MyLink>
  </li>
  <ol>
    <li>
      <MyLink href="#scene_config">scene_config</MyLink>
    </li>
    <li>
      <MyLink href="#rtmidi">rtmidi</MyLink>
    </li>
  </ol>
  <li>
    <MyLink href="#ableton-live-setup">Ableton Live Setup</MyLink>
  </li>
  <li>
    <MyLink href="#source-code">Source Code</MyLink>
  </li>
</ol>

<hr />

<h1 id="system-overview">System Overview</h1>

<MyImage
  src="/img/abletonmidi-system-diagram.png"
  alt="system diagram of my setup."
/>

My solution enables navigatation of Ableton's session view like a 2D matrix, skipping up and down in the DAW window using only two buttons on a midi controller (one for scene-skipping, and one for track-skipping).

The system consists of 4 components:

<ul>
  <li>A USB midi keyboard or controller</li>
  <li>a Python setup with rtmidi library installed</li>
  <li>A virtual midi driver</li>
  <li>Ableton Live 11</li>
</ul>

In my personal setup I use a MIDIPLUS x4 midi keyboard connected to my thinkpad P53 laptop via USB. As a virtual midi driver, I use <MyLink href="https://www.tobias-erichsen.de/software/loopmidi.html">Tobias Erichsens loopMIDI</MyLink>. For Mac users, I recommend setting up a IAC virtual midi bus. No third-party programs required.

<h1 id="python-setup">Python Setup</h1>

The Python code as two primary jobs. First, to intercept midi messages from the controller and pass them to Ableton Live using the rtmidi library. And second, to associate collections of Ableton tracks with scenes and customize the track skipping order.

<MyImage
  src="/img/abletonmidi-overview2-wkeys.gif"
  alt="overview of my setup with keys"
  caption="By associating specific tracks with specific scenes in Ableton Live, I can navigate complex live sets using very few controls."
/>

<h3 id="scene-config">scene_config</h3>

To represent Ableton Live's session view window in Python, define a dictionary called scene_config. The dictionary key-value pairs represent the scenes (keys) and tracks (values) of our Ableton session. Each key represents a scene, and each value represents a collection (array) of tracks (integers).

Using this strategy, we can skip between different collections of tracks based on the current scene as shown in the code below:

```Python
scene_config = {
  1 : [0],
  2 : [0, 1],
  3 : [0, 2],
  4 : [0, 1, 4] # scene nr.4 skips between track/synth 0, 1 and 4.
}
```

Skipping between tracks is achieved by asynchronously iterating over the scene_config arrays in response to keypresses from the controller. To handle this functionality, I use a Generator function called yield.

Python Generators are special functions that return <MyLink href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy iterator</MyLink>. With these objects, we can iterate over array items one-by-one asynchronously without having to keep track of the previous index.

The yield function also handles the looping aspect by returning to start (0th index item) when iterating past the last array item (-1st index).

```Python
# ...
# Use yield to asynchronously iterate and loop over arrays with next()
def nextTrack(scene):
  count = 0
  while True:
      yield scene[count]
      if count < (len(scene)-1):
          count += 1
      else:
          count = 0

current_scene = 4
track = nextTrack(scene_config[current_scene])

print(next(track))
print(next(track))
print(next(track))
print(next(track))

# outputs:
# 0
# 1
# 4
# 0 - back to start
```

In the above example, I pass a scene (array) from scene_config into the nextTrack function. The function returns a generator object I can use to asynchronously iterate over the array using the next() function.

To see how I actually implemented this technique into my live setup, visit the <MyLink href="#source-code">source code section</MyLink> below.

<h3 id="rtmidi">rtmidi</h3>

The second job of the Python program is to handle the midi communication between the controller and Ableton Live.
{/* I AM HERE */}
In this case, the system requires two midi devices; one physical (USB controller) and one virtual (loopMIDI).

The <MyLink href="https://pypi.org/project/python-rtmidi/">rtmidi</MyLink> Python library makes it pretty straightforward to initialize midi communication between devices.

```Python
# initialize midi in and out communication with a simple UI
def midi_INIT():
    print('Available MIDI input ports:')
    midi_in = rtmidi.MidiIn()
    for port, name in enumerate(midi_in.get_ports()):
        print(port, ': ', name)

    input_port = int(input('which port should I get MIDI from?: '))
    midi_in_opened = midi_in.open_port(input_port)

    print('Receiving MIDI from port: ', input_port)

    return midi_in_opened

midi_in = midi_INIT()

# outputs:
# Available MIDI input ports:
# 0 :  Physical USB controller
# 1 :  loopMIDI Port 1
# which port should I get MIDI from?: USER INPUT...
```

In the above example, a simple midi initialization process is defined... ins and outs.. The program reads out the available midi devices and asks which device it should use as its input. Here we choose the physical midi controller as our input.

The same code can be repeated for the midi output initialization, only substituting rtmidi.MidiIn() with rtmidi.MidiOut(). Choose the virtual midi driver as your midi output device.

To send messages, the rtmidi objects have a send_message method that only requires the midi channel, note, and ON/OFF messages as arguments.

```Python
# Send a note-on midi message on note 100 to the virtual midi driver
midi_in, midi_out = midi_INIT()

midi_channel = 1
midi_note = 100 # coming from you controller (+ offset)
note_on_off = 127 # 127 for ON, 0 for off
message = [midi_channel, midi_note, note_on_off]

midi_out.send_message(message)
```

Finally, after initializing your midi communication, you must locate the correct midi note messages from your controller buttons. With rtmidi, we can print out raw midi messages as such:

```Python
#src/keyboard-test.py
# Prints out the midi messages from your device to the console.
midi_in, midi_out = midi_INIT()
with midi_in:
    prev_message = []
    while True:
        message = midi_in.get_message() # this is important method
        if message and message is not prev_message:
            print(message)
            prev_message = message
```

<h1 id="ableton-live-setup">Ableton Live Setup</h1>

In Ableton Live's session view, ensure that the number of scenes and tracks corresponds to the scene_config dictionary. Then, you are ready for the midi mapping process.

To make the midi mapping process as safe and reliable as possible, I recommend using Python to guide your mapping based on your scene_config. Having a single source of truth is always a good programming strategy.

<MyImage
  src="/img/abletonmidi-ableton-midi-mapping.png"
  alt="Ableton Live midi mapping."
  caption="Making a `daw-midi-mapping.py` is recommended when your Ableton setup is so tighly coupled with Python variables."
/>

Finally, we have to set up the correct midi communication between Python, Ableton, and your controller. Per default, Ableton will recognize and enable any compatible midi device it detects. However, we only want Ableton to listen to the data from Python, so we have to configure some settings.

Hit **ctrl +,** in Ableton to open preferences and navigate to the midi section. Uncheck every box except "Track" and "Sync" on the virtual midi driver input.

<MyImage
  src="/img/abletonmidi-ableton-midi.jpg"
  alt="Ableton Live midi config."
/>

Now you should be ready to go.

<h1 id="source-code">Source Code</h1>

The full source code of this project is open source and available on <MyLink href="https://github.com/aleksati/ableton-navigation-system">my GitHub</MyLink>.

If you want to contribute, you are free to do so. Simply fork the repo and make a pull request.
