---
title: "Using Python to Control Ableton Live"
date: "2023-03-10"
keywords: ["audio", "performance", "ableton", "python", "midi"]
summary: "While designing a new liveset with my band, I wrote some code to help me better and more efficiently navigate Ableton Live's session view using very few midi controls. Here is how I did it."
---

<MyImage
  src="/img/abletonmidi-overview1.gif"
  alt="overview of my setup to navigate Ableton Live using python"
/>

Designing live performances for <MyLink url="https://theholymountain.net">The Holy Mountain</MyLink> (my band) has always been challenging. We are only three members, and the music is very complicated. During our live sets, we have to manage looping, sample triggering, complex tempo changes, and fast navigation between synthesizer presets. We also insist on playing most of the musical parts ourselves, which is annoying.

Recently, I have been trying to figure out how to play drums and synthesizers simultaneously, drumming with my left hand (and legs) and playing synth with my right hand. This problem inspired me to develop a clever way to navigate <MyLink href="https://ableton.com/">Ableton Live</MyLink> using very few midi controls, minimizing time spent fiddling with Ableton while playing without compromising on technical freedom and musical complexity.

In this post, I present my solution and demonstrate how you can use some Python code (especially Generator objects) between your midi controller and DAW to achieve awesome midi mapping capabilities.

# Contents

<ol>
  <li>
    <MyLink href="#system-overview">System overview</MyLink>
  </li>
  <li>
    <MyLink href="#python-setup">Python Setup</MyLink>
  </li>
  <ol>
    <li>
      <MyLink href="#scene_config">scene_config</MyLink>
    </li>
    <li>
      <MyLink href="#rtmidi">rtmidi</MyLink>
    </li>
  </ol>
  <li>
    <MyLink href="#ableton-live-setup">Ableton Live Setup</MyLink>
  </li>
  <li>
    <MyLink href="#source-code">Source Code</MyLink>
  </li>
</ol>

<hr />

<h1 id="system-overview">System Overview</h1>

<MyImage
  src="/img/abletonmidi-system-diagram.png"
  alt="system diagram of my setup."
/>

The system consists of 4 necessary components:

<ul>
  <li>A USB midi keyboard or controller</li>
  <li>a Python program using the rtmidi and python-osc libraries</li>
  <li>A virtual midi driver</li>
  <li>Ableton Live 11</li>
</ul>

The Python program intercepts midi messages from the controller before sending the messages to Ableton Live using a virtual midi port.

The program/code enables me to navigate Ableton's session view like a 2D matrix, skipping up and down in the DAW window using only two buttons on the midi controller (one for scene-skipping, and one for track-skipping).

Further, using Python enables me to associate a unique set of synths to each Ableton scene and customize the track-skipping order as I wish.

<MyImage
  src="/img/abletonmidi-overview2-wkeys.gif"
  alt="overview of my setup with keys"
  caption="By associating specific tracks with specific scenes in Ableton Live, I can navigate complex live sets using very few controls."
/>

In my personal setup I use a MIDIPLUS x4 midi keyboard connected to my thinkpad P53 laptop via USB. As a virtual midi driver, I use <MyLink href="https://www.tobias-erichsen.de/software/loopmidi.html">Tobias Erichsens loopMIDI</MyLink>. For Mac users, I recommend setting up a IAC virtual midi bus. No third-party programs required.

<h1 id="python-setup">Python Setup</h1>

The job of the Python code is to receive messages from the midi controller and alter them, based on the state of the system, before passing them on to Ableton.

<h3 id="scene-config">scene_config</h3>

The key component of the Python setup is the scene_config dictionary. This object represents Ableton Live's session view window as key-value pairs (scenes and tracks). Each key represents an Ableton scene, and each value (array) represents a collection of tracks.

Using this strategy, I can skip between track constellations based on the current scene.

```Python
scene_config = {
  1 : [0],
  2 : [0, 1],
  3 : [0, 2],
  4 : [0, 1, 4] # scene nr.4 skips between track/synth 0, 1 and 4.
}
```

Skipping between tracks is achieved by looping over the scene_config arrays in response to midi keypresses.

I use a Python generator function called yield to manage track skipping. Python Generators are special functions that return <MyLink href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy iterator</MyLink>. With these objects, you can iterate over array items asynchronously (one by one) without keeping track of the previous index. The object also handles the looping aspect by returning to start (0th index) when iterating past the last array item (-1st index).

```Python
# ...
def nextTrack(scene):
  count = 0
  while True:
      yield scene[count]
      if count < (len(scene)-1):
          count += 1
      else:
          count = 0

current_scene = 4
track = nextTrack(scene_config[current_scene])

print(next(track))
print(next(track))
print(next(track))
print(next(track))

# outputs:
# 0
# 1
# 4
# 0 - back to start
```

In the above example, I use the nextTrack function to iterate over a desired scene_config key (Ableton scene). The function returns a generator object I can asynchronously (on demand) loop over using the next() function.

<h3 id="rtmidi">rtmidi</h3>

The second job of the Python program is to mediate the midi connections by handling the messages from the controller before sending them off to Ableton. In this case, the system requires two midi devices; one physical (USB controller) and one virtual (loopMIDI).

The <MyLink href="https://pypi.org/project/python-rtmidi/">rtmidi</MyLink> Python library makes it pretty straightforward to initialize midi communication between devices.

```Python
# initialize the rtmidi python communication with a simple UI
def midi_INIT():
    print('Available MIDI input ports:')
    midi_in = rtmidi.MidiIn()
    for port, name in enumerate(midi_in.get_ports()):
        print(port, ': ', name)

    input_port = int(input('which port should I get MIDI from?: '))
    midi_in_opened = midi_in.open_port(input_port)

    print('Receiving MIDI from port: ', input_port)

    return midi_in_opened

midi_in = midi_INIT()

# outputs:
# Available MIDI input ports:
# 0 :  Physical USB controller
# 1 :  loopMIDI Port 1
# which port should I get MIDI from?: USER INPUT...
```

In the above example, a simple rtmidi initialization process is defined. The program reads out the available midi devices and asks which device it should use as its input. Here we choose the physical midi controller as our input.

The same code can be repeated for the midi output initialization, only substituting rtmidi.MidiIn() with rtmidi.MidiOut(). Choose the virtual midi driver as your midi output device.

To send messages, the rtmidi objects have a send_message method that only requires the midi channel, note, and ON/OFF messages as arguments.

```Python
# Send a note-on midi message on note 100 to the virtual midi driver
midi_in, midi_out = midi_INIT()

midi_channel = 1
midi_note = 100 # coming from you controller (+ offset)
note_on_off = 127 # 127 for ON, 0 for off
message = [midi_channel, midi_note, note_on_off]

midi_out.send_message(message)
```

Finally, after initializing your midi communication, you must locate the correct midi note messages from your controller buttons. With rtmidi, we can print out raw midi messages as such:

```Python
#src/keyboard-test.py
# Prints out the midi messages from your device to the console.
midi_in, midi_out = midi_INIT()
with midi_in:
    prev_message = []
    while True:
        message = midi_in.get_message() # this is important method
        if message and message is not prev_message:
            print(message)
            prev_message = message
```

<h1 id="ableton-live-setup">Ableton Live Setup</h1>

In Ableton Live's session view, ensure that the number of scenes and tracks corresponds to the scene_config dictionary. Then, you are ready for the midi mapping process.

To make the midi mapping process as safe and reliable as possible, I recommend using Python to guide your mapping based on your scene_config. Having a single source of truth is always a good programming strategy.

<MyImage
  src="/img/abletonmidi-ableton-midi-mapping.png"
  alt="Ableton Live midi mapping."
  caption="Making a `daw-midi-mapping.py` is recommended when your Ableton setup is so tighly coupled with Python variables."
/>

Finally, we have to set up the correct midi communication between Python, Ableton, and your controller. Per default, Ableton will recognize and enable any compatible midi device it detects. However, we only want Ableton to listen to the data from Python, so we have to configure some settings.

Hit **ctrl +,** in Ableton to open preferences and navigate to the midi section. Uncheck every box except "Track" and "Sync" on the virtual midi driver input.

<MyImage
  src="/img/abletonmidi-ableton-midi.jpg"
  alt="Ableton Live midi config."
/>

Now you should be ready to go.

<h1 id="source-code">Source Code</h1>

The full source code of this project is open source and available on <MyLink href="https://github.com/aleksati/ableton-navigation-system">my GitHub</MyLink>.

If you want to contribute, you are free to do so. Simply fork the repo and make a pull request.
