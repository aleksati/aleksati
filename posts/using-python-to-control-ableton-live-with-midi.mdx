---
title: "Using Python to Control Ableton Live With MIDI"
date: "2023-04-10"
keywords:
  [
    "music tech",
    "python",
    "midi",
    "realtime",
    "audio",
    "ableton",
    "live",
    "python-rtmidi",
    "python-osc",
    "drums",
    "synth",
    "live electronics",
  ]
type: "post"
summary: "While designing a new liveset for my band, I wrote some code to help me navigate Ableton Live more efficiently (like a 2D matrix) using very few midi controls. Here is what I did, and how."
---

<MyImage
  src="abletonmidi-overview1.gif"
  alt="overview of my setup to navigate Ableton Live using python"
/>

Designing live performances for <MyLink url="https://theholymountain.net">The Holy Mountain</MyLink> (my band) has always been challenging. During our live sets, we have to manage looping, sample triggering, complex tempo changes, and fast navigation between synthesizer presets.

For our upcoming liveset, I have been trying to figure out how to play drums and synthesizers simultaneously, playing synth with my right hand and drumming with my remaining limbs. This problem inspired me to develop a clever way to navigate Ableton Live using very few midi controls.

In this post, I present my solution and demonstrate how you can use some Python code (essentially Generator objects and rtmidi) to achieve awesome midi mapping capabilities between your midi controller and DAW.

# Contents

1. <MyLink href="#system-overview">System overview</MyLink>
2. <MyLink href="#python-setup">Python Setup</MyLink>
   1. <MyLink href="#scene-config">scene config</MyLink>
   2. <MyLink href="#skipping-tracks">Skipping Tracks With Yield</MyLink>
   3. <MyLink href="#rtmidi">rtmidi</MyLink>
3. <MyLink href="#ableton-live-setup">Ableton Live Setup</MyLink>
4. <MyLink href="#source-code">Source Code</MyLink>

<hr />

# System Overview

<MyImage
  src="abletonmidi-system-diagram.png"
  alt="system diagram of my setup."
/>

My solution enables navigatation of Ableton Live's session view window like a 2D matrix, skipping up and down scenes and between audio tracks using only two buttons on a midi controller.

The system consists of 4 components:

<ul>
  <li>A USB midi keyboard or controller</li>
  <li>a Python setup with the rtmidi library</li>
  <li>A virtual midi driver</li>
  <li>Ableton Live 11</li>
</ul>

In my personal setup I use a MIDIPLUS X4 midi keyboard connected to my windows 10 machine via USB. As a virtual midi driver, I use <MyLink href="https://www.tobias-erichsen.de/software/loopmidi.html">Tobias Erichsens loopMIDI</MyLink>. For Mac users, I recommend setting up a IAC virtual midi bus. No third-party programs required.

# Python Setup

The Python code as two primary jobs. First, to intercept midi messages from the controller and pass them to Ableton Live. And second, to associate collections of Ableton tracks with scenes and customize the track _skipping order_.

<MyImage
  src="abletonmidi-overview2-wkeys.gif"
  alt="overview of my setup with keys"
  caption="By associating unique track constellations with specific scenes in Ableton, I can navigate complex live sets using very few controls."
/>

### scene config

To represent Ableton Live's session view window in Python, I define a dictionary called scene_config. The dictionary's key-value pairs represent the Ableton window as a 2D stucture. Each key represents a scene, and each value represents a collection (array) of tracks (integers).

Using this strategy, I can skip between different collections of tracks based on the current scene.

```Python
scene_config = {
  1 : [0],
  2 : [0, 1],
  3 : [0, 2],
  4 : [0, 1, 4] # scene nr.4 skips between track 0, 1 and 4.
}
```

### Skipping Tracks

To skip between audio tracks, I iterating and loop over the scene_config arrays asynchronously in response to keypresses from my USB controller. To handle this kind of functionality, I recommend using the Yield generator function in Python.

Python Generators are special functions that return <MyLink href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy iterator</MyLink>. With these objects, you can iterate over array items one-by-one asynchronously without having to keep track of the previous or current index.

The yield function also handles the looping aspect as it returns to start (0th index item) when iterating past the last item in an array (-1st index).

```Python
# ...
# Use yield to asynchronously iterate and loop over arrays with next()
def nextTrack(scene):
  count = 0
  while True:
      yield scene[count]
      if count < (len(scene)-1):
          count += 1
      else:
          count = 0

current_scene = 4
track = nextTrack(scene_config[current_scene])

print(next(track))
print(next(track))
print(next(track))
print(next(track))

# outputs:
# 0
# 1
# 4
# 0 - back to start
```

In the above example, I pass a scene (array) from scene_config into the nextTrack function. The function returns a generator object I can use to asynchronously iterate over the array using the next() function.

To see how I implemented this technique into my actual live setup, visit the <MyLink href="#source-code">source code section</MyLink> below.

### rtmidi

The second job of the Python program is to handle the midi communication between the controller and Ableton Live. I have to use two midi devices for this to work, one physical USB controller (the input) and one virtual midi driver (the output going to Ableton Live).

Fortunatley, it's fairly straightforward to initialize communication between multiple midi devices using the <MyLink href="https://pypi.org/project/python-rtmidi/">rtmidi</MyLink> Python library.

```Python
# initialize midi in and out communication with a simple UI
def midi_INIT():
    print('Available MIDI input ports:')
    midi_in = rtmidi.MidiIn()
    for port, name in enumerate(midi_in.get_ports()):
        print(port, ': ', name)

    input_port = int(input('which port should I get MIDI from?: '))
    midi_in_opened = midi_in.open_port(input_port)

    print('Receiving MIDI from port: ', input_port)

    return midi_in_opened

midi_in = midi_INIT()

# outputs:
# Available MIDI input ports:
# 0 :  Physical USB controller
# 1 :  loopMIDI Port 1
# which port should I get MIDI from?: USER INPUT...
```

In the above example, a simple midi input initialization process is defined. The program reads out the available midi devices and asks which device it should use as its input. Here, I choose the physical controller as my input device.

To initialize a midi output connection, I repeat the code, only substituting rtmidi.MidiIn() with rtmidi.MidiOut() and using the virtual midi driver as my device.

To send messages, rtmidi objects have a send_message() method to use on initialized midi objects. As arguments, the method requires the midi channel, note value, and ON/OFF message.

```Python
# Send a note-on midi message on note 100 to the virtual midi driver
midi_in, midi_out = midi_INIT()

midi_channel = 1
midi_note = 100 # coming from you controller (+ offset)
note_on_off = 127 # 127 for ON, 0 for off
message = [midi_channel, midi_note, note_on_off]

midi_out.send_message(message)
```

**Pro tip:** If you're unsure about what kind of messages or values your midi devices in sending, you can print out raw midi messages from a rtmidi connection with a simple keyboard-test script. I use this script to orient myself with new midi devices:

```Python
# src/keyboard-test.py
# Prints out the midi messages from your device to the console.
midi_in, midi_out = midi_INIT()
with midi_in:
    prev_message = []
    while True:
        message = midi_in.get_message() # this is important method
        if message and message is not prev_message:
            print(message)
            prev_message = message
```

# Ableton Live Setup

In Ableton, I have to do the correct midi mapping and enable the right midi settings.

Before midi mapping, I ensure that the number of scenes and tracks in my Ableton window are correct by running a script that guides me through the mapping process based on my scene_config dictionary. Having a single source of truth is always a good programming strategy to increase reliability and efficiency.

<MySlideshow
  imgs={[
    "abletonmidi-ableton-midi-mapping.png",
    "abletonmidi-ableton-midi.png",
  ]}
  captions={[
    "Making a `daw-midi-mapping.py` is recommended when your Ableton setup is tighly coupled with Python variables.",
    "Configure the midi settings to listen for data from python.",
  ]}
/>

Finally, I have to set the correct midi settings in Ableton. As default, Ableton will usually recognize and enable any compatible midi device it detects. However, I only want Ableton to listen to the data from Python, not from the controller.

To open the midi preferences, Hit **"ctrl" + ","** and navigate to the midi section. The only midi input I want is from the virtual midi driver, so I uncheck every other device.

# Source Code

The full source code of this project is open source and available on <MyLink href="https://github.com/aleksati/ableton-navigation-system">my GitHub</MyLink>.

If you want to contribute, you are free to do so. Simply fork the repo and make a pull request.
